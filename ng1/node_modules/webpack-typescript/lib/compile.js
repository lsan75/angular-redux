/// <reference path="../typings/node/node.d.ts" />
var ts = require('typescript');
var LanguageServiceHost_1 = require('./LanguageServiceHost');
var CompilationResult_1 = require('./CompilationResult');
var languageServiceHost = new LanguageServiceHost_1.default();
var languageService = ts.createLanguageService(languageServiceHost);
function compile(request, dependencies, diagnostics) {
    languageServiceHost.setCompilationRequest(request, dependencies);
    var program = languageService.getProgram();
    var result = new CompilationResult_1.default();
    var emitResult = request.options.noEmit ? null : emit();
    collectDiagnostics();
    return result;
    function emit() {
        var emitResult = program.emit(void 0, function (fileName, data) {
            if (fileName.slice(-4) === '.map') {
                result.sourceMap = JSON.parse(data);
            }
            else {
                result.output = data;
            }
        });
        if (!result.output || emitResult.emitSkipped) {
            result.output = null;
            result.sourceMap = null;
        }
        else if (result.sourceMap) {
            result.output = result.output.slice(0, result.output.lastIndexOf('//# sourceMappingURL='));
        }
        return emitResult;
    }
    function collectDiagnostics() {
        // We are trying to mimic output of tsc
        diagnostics.add(program.getSyntacticDiagnostics());
        if (diagnostics.isEmpty) {
            if (program.getOptionsDiagnostics) {
                diagnostics.add(program.getOptionsDiagnostics());
            }
            diagnostics.add(program.getGlobalDiagnostics());
            if (diagnostics.isEmpty) {
                diagnostics.add(program.getSemanticDiagnostics());
            }
        }
        if (emitResult) {
            diagnostics.add(emitResult.diagnostics);
        }
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = compile;
