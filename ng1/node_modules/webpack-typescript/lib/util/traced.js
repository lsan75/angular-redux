var trace_1 = require('./trace');
var COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var FN_NAME = /^\s*function\s*([^\s\(]*)/m;
var FN_ARGS = /\(([^\)]*)\)/m;
function getFunctionText(fn) {
    return fn.toString().replace(COMMENTS, '');
}
function getFunctionName(fn) {
    return getFunctionText(fn).match(FN_NAME)[1];
}
function getFunctionArgNames(fn) {
    var args = getFunctionText(fn).match(FN_ARGS)[1].trim();
    return args ? args.split(',').map(function (arg) { return arg.trim(); }) : [];
}
function stringify(value) {
    return JSON.stringify(value, null, '\t');
}
var tracedMethod = trace_1.default.enabled ? function (options) {
    var skipReturn = options && options.return === false;
    return function (target, propertyKey, descriptor) {
        var methodName = getFunctionName(target.constructor) + '#' + propertyKey.toString();
        var method = descriptor.value;
        if (typeof method !== 'function') {
            throw new TypeError("@traceMethod: " + methodName + " is not a method");
        }
        var argNames = getFunctionArgNames(method);
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            trace_1.default('CALL: ' + methodName);
            trace_1.default.increaseIndent();
            for (var i = 0; i < Math.max(argNames.length, args.length); i++) {
                trace_1.default('ARG ' + argNames[i] + ': ' + stringify(args[i]));
            }
            try {
                var result = method.apply(this, args);
                if (!skipReturn) {
                    trace_1.default('RETURN: ' + stringify(result));
                }
                return result;
            }
            catch (err) {
                trace_1.default('THROW: ' + stringify(err));
                throw err;
            }
            finally {
                trace_1.default.decreaseIndent();
                trace_1.default('EXIT: ' + methodName);
            }
        };
    };
} : function () { return function () { }; };
exports.tracedMethod = tracedMethod;
