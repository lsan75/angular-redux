/// <reference path="../typings/node/node.d.ts" />
/// <reference path="../typings/loader-utils.d.ts" />
var loaderUtils = require('loader-utils');
var path = require('path');
var fs = require('fs');
var Diagnostics_1 = require('./Diagnostics');
var Dependencies_1 = require('./Dependencies');
var OptionsBuilder_1 = require('./OptionsBuilder');
var compile_1 = require('./compile');
var CompilationRequest_1 = require('./CompilationRequest');
var baseDir_1 = require('./baseDir');
var trace_1 = require('./util/trace');
function loadTypeScript(loaderContext, input) {
    var diagnostics = new Diagnostics_1.default();
    var dependencies = new Dependencies_1.default();
    trace_1.default('LOAD: ' + loaderContext.resourcePath);
    setupLoader();
    var query = loaderUtils.parseQuery(loaderContext.query);
    var configFile = readConfigFile();
    var options = prepareOptions();
    var result = diagnostics.isEmpty ? compileInput() : {};
    stateDependencies();
    sendResult();
    function setupLoader() {
        loaderContext.cacheable();
    }
    function readConfigFile() {
        var result = {
            path: null,
            content: null
        };
        var dir = baseDir_1.default;
        while (true) {
            var filePath = path.resolve(dir, 'tsconfig.json');
            // Add every tried path to the dependencies, because even if the file currently doesn't exist, it may become available later.
            dependencies.add(filePath);
            try {
                result.content = fs.readFileSync(filePath, 'utf8');
                result.path = path.relative(baseDir_1.default, filePath);
                break;
            }
            catch (err) { }
            var parent_1 = path.dirname(dir);
            if (parent_1 === dir) {
                break;
            }
            dir = parent_1;
        }
        return result;
    }
    function prepareOptions() {
        var optionsBuilder = new OptionsBuilder_1.default(diagnostics);
        if (configFile.content) {
            trace_1.default('CONFIG FILE: ' + configFile.path);
            optionsBuilder.addConfigFileText(configFile.path, configFile.content);
        }
        else {
            trace_1.default('CONFIG FILE WAS NOT FOUND');
        }
        optionsBuilder.addConfig({ compilerOptions: query }, baseDir_1.default);
        return optionsBuilder.build(loaderContext.sourceMap);
    }
    function compileInput() {
        var request = Object.freeze(new CompilationRequest_1.default(loaderContext.resourcePath, input, options));
        var result = compile_1.default(request, dependencies, diagnostics);
        if (result.sourceMap) {
            result.sourceMap.sources = [loaderUtils.getRemainingRequest(loaderContext)];
        }
        return result;
    }
    function stateDependencies() {
        dependencies.forEach(function (filePath) {
            trace_1.default('DEPENDENCY: ' + filePath);
            loaderContext.dependency(filePath);
        });
    }
    function sendResult() {
        var messages = diagnostics.toString();
        if (typeof result.output === 'string') {
            process.stdout.write(messages);
            loaderContext.callback(null, result.output, result.sourceMap);
        }
        else if (messages) {
            loaderContext.callback(new Error('TypeScript compilation failed:\n' + messages));
        } // noEmit
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = loadTypeScript;
