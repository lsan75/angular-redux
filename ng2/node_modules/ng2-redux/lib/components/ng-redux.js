"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var shallowEqual_1 = require('../utils/shallowEqual');
var wrapActionCreators_1 = require('../utils/wrapActionCreators');
var Redux = require('redux');
var _ = require('lodash');
var rxjs_1 = require('rxjs');
var core_1 = require('@angular/core');
var invariant_1 = require('../utils/invariant');
var VALID_SELECTORS = ['string', 'number', 'symbol', 'function'];
var ERROR_MESSAGE = "Expected selector to be one of: \n" + VALID_SELECTORS.join(',') + ". Instead recieved %s";
var checkSelector = function (s) { return VALID_SELECTORS.indexOf(typeof s, 0) >= 0; };
var NgRedux = (function () {
    /**
     * Creates an instance of NgRedux.
     *
     * @param {Redux.Store<RootState>} store Redux store
     */
    function NgRedux(store) {
        var _this = this;
        /**
         * Create an observable from a Redux store.
         *
         * @param {Store<RootState>} store Redux store to create an observable from
         * @returns {BehaviorSubject<RootState>}
         */
        this.observableFromStore = function (store) {
            return new rxjs_1.BehaviorSubject(store.getState());
        };
        this.wrapActionCreators = function (actions) { return wrapActionCreators_1.default(actions); };
        /**
         * Map the specified actions to the target
         * @param {any} actions the actions to bind to the target
         * @returns {(target:any)=>void} a function to pass your target into
         */
        this.mapDispatchToTarget = function (actions) { return function (target) {
            return _this.updateTarget(target, {}, _this.getBoundActions(actions));
        }; };
        /**
         * Connect your component to your redux state.
         *
         * @param {*} mapStateToTarget connect will subscribe to Redux store updates. Any time it updates, mapStateToTarget will be called. Its result must be a plain object, and it will be merged into `target`. If you have a component which simply triggers actions without needing any state you can pass null to `mapStateToTarget`.
         * @param {*} mapDispatchToTarget  Optional. If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but bound to a Redux store, will be merged onto `target`. If a function is passed, it will be given `dispatch`. Itâ€™s up to you to return an object that somehow uses `dispatch` to bind action creators in your own way. (Tip: you may use the [`bindActionCreators()`](http://gaearon.github.io/redux/docs/api/bindActionCreators.html) helper from Redux.).
         * @returns a function that accepts a target object to map the state and/or dispatch onto, or a function that will recieve the result of mapStateToTarget and mapDispatchToTarget as paramaters
         */
        this.connect = function (mapStateToTarget, mapDispatchToTarget) {
            var finalMapStateToTarget = mapStateToTarget
                || _this._defaultMapStateToTarget;
            invariant_1.invariant(_.isFunction(finalMapStateToTarget), 'mapStateToTarget must be a Function. Instead received %s.', finalMapStateToTarget);
            var slice = _this.getStateSlice(_this._store.getState(), finalMapStateToTarget);
            var boundActionCreators = _this.getBoundActions(mapDispatchToTarget);
            return function (target) {
                invariant_1.invariant(_.isFunction(target) || _.isObject(target), 'The target parameter passed to connect must be a Function or' +
                    'a plain object.');
                // Initial update
                _this.updateTarget(target, slice, boundActionCreators);
                var unsubscribe = _this._store.subscribe(function () {
                    var nextSlice = _this.getStateSlice(_this._store.getState(), finalMapStateToTarget);
                    if (!shallowEqual_1.default(slice, nextSlice)) {
                        slice = nextSlice;
                        _this.updateTarget(target, slice, boundActionCreators);
                    }
                });
                return unsubscribe;
            };
        };
        /**
         * Get the current state of the application
         * @returns {RootState} the application state
         */
        this.getState = function () {
            return _this._store.getState();
        };
        /**
         * Subscribe to the Redux store changes
         *
         * @param {() => void} listener callback to invoke when the state is updated
         * @returns a function to unsubscribe
         */
        this.subscribe = function (listener) {
            return _this._store.subscribe(listener);
        };
        /**
        * Replaces the reducer currently used by the store to calculate the state.
        *
        * You might need this if your app implements code splitting and you want to
        * load some of the reducers dynamically. You might also need this if you
        * implement a hot reloading mechanism for Redux.
        *
        * @param nextReducer The reducer for the store to use instead.
        */
        this.replaceReducer = function (nextReducer) {
            return _this._store.replaceReducer(nextReducer);
        };
        /**
         * Dispatch an action to Redux
         */
        this.dispatch = function (action) {
            return _this._store.dispatch(action);
        };
        this.getBoundActions = function (actions) {
            var finalMapDispatchToTarget = _.isPlainObject(actions) ?
                wrapActionCreators_1.default(actions) :
                actions || _this._defaultMapDispatchToTarget;
            invariant_1.invariant(_.isPlainObject(finalMapDispatchToTarget)
                || _.isFunction(finalMapDispatchToTarget), 'mapDispatchToTarget must be a plain Object or a Function. ' +
                'Instead received % s.', finalMapDispatchToTarget);
            return finalMapDispatchToTarget(_this._store.dispatch);
        };
        this._store = store;
        this._store$ = this.observableFromStore(store);
        this._store.subscribe(function () { return _this._store$.next(_this._store.getState()); });
        this._defaultMapStateToTarget = function () { return ({}); };
        this._defaultMapDispatchToTarget = function (dispatch) { return ({ dispatch: dispatch }); };
        var cleanedStore = _.omit(store, ['dispatch', 'getState', 'subscribe', 'replaceReducer']);
        Object.assign(this, cleanedStore);
    }
    /**
     * Select a slice of state to expose as an observable.
     *
     * @template S
     * @param {(string | number | symbol | ((state: RootState) => S))} selector key or function to select a part of the state
     * @param {(x: any, y: any) => boolean} [comparer]  optional comparison function called to test if an item is distinct from the previous item in the source.
     * @returns {Observable<S>} an Observable that emits items from the source Observable with distinct values.
     */
    NgRedux.prototype.select = function (selector, comparer) {
        invariant_1.invariant(checkSelector(selector), ERROR_MESSAGE, selector);
        if (typeof selector === 'string' ||
            typeof selector === 'number' ||
            typeof selector === 'symbol') {
            return this._store$
                .map(function (state) { return state[selector]; })
                .distinctUntilChanged(comparer);
        }
        else if (typeof selector === 'function') {
            return this._store$
                .map(selector).distinctUntilChanged(comparer);
        }
    };
    NgRedux.prototype.updateTarget = function (target, StateSlice, dispatch) {
        if (_.isFunction(target)) {
            target(StateSlice, dispatch);
        }
        else {
            _.assign(target, StateSlice, dispatch);
        }
    };
    NgRedux.prototype.getStateSlice = function (state, mapStateToScope) {
        var slice = mapStateToScope(state);
        invariant_1.invariant(_.isPlainObject(slice), '`mapStateToScope` must return an object. Instead received %s.', slice);
        return slice;
    };
    NgRedux = __decorate([
        core_1.Injectable(), 
        __metadata('design:paramtypes', [Object])
    ], NgRedux);
    return NgRedux;
}());
exports.NgRedux = NgRedux;
//# sourceMappingURL=ng-redux.js.map